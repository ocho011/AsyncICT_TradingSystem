# 비동기/동기 REST API 관련 질문

## 1. 이벤트 처리기는 awaitable 해야 하는가?

이 프로젝트의 EventBus (AsyncEventBus) 구현을 보면, 이벤트 처리기(handler)는 반드시 `async` 함수(코루틴)여야 한다고 명시되어 있습니다. 이는 곧...

*   EventBus 내부에서 `await handler(event)`를 호출합니다.
*   이벤트 처리기는 비동기적으로 동작하며, 이벤트 처리기가 EventBus의 이벤트 루프를 블로킹하지 않도록 하기 위함입니다. 따라서 이벤트 처리기는 awaitable이어야 합니다.

## 2. REST API로도 주문을 할 수 있는가?

일반적인 REST API 호출이 동기적으로 보일 수 있지만, 파이썬의 asyncio 프레임워크와 비동기 HTTP 클라이언트 라이브러리(예: aiohttp)를 사용하면 REST API 호출을 비동기적으로 수행할 수 있습니다.

*   **동기적 API 호출**: 클라이언트 코드가 API 요청을 보낸 후, 응답이 올 때까지 실행을 멈추고 기다립니다. (예: Python `requests` 라이브러리)
*   **비동기적 API 호출**: 클라이언트 코드가 API 요청을 보낸 후, 응답을 기다리지 않고 다른 작업을 계속 수행합니다. (예: Python `aiohttp` + `asyncio`)

이 프로젝트의 `AsyncBinanceRestClient`는 `aiohttp`를 사용하여 REST API 호출을 비동기적으로 수행하고 있습니다. 따라서 이벤트 처리기 내에서 비동기 REST API 호출을 해도 문제가 없습니다.

## 3. await의 동작 방식

`await`가 붙은 비동기 함수를 호출하면 현재 실행 중인 코루틴(함수)의 실행은 일시적으로 중단됩니다.

*   **동기 방식**: I/O 작업이 완료될 때까지 프로그램 전체가 블로킹됩니다.
*   **비동기 방식**: I/O 작업이 백그라운드에서 진행되는 동안 프로그램은 블로킹되지 않고 다른 작업을 계속 수행합니다.

즉, `await`는 현재 코루틴의 실행을 일시 중단시키지만, 이벤트 루프는 다른 코루틴을 실행하여 프로그램 전체는 블로킹되지 않습니다.

## 4. 블로킹과 논블로킹의 주체와 객체

### 블로킹

*   **주체**: 실행 흐름 (스레드, 프로세스)
*   **객체**: I/O 작업 (네트워크 요청, 파일 읽기/쓰기, DB 쿼리 등)
*   **의미**: I/O 작업이 완료될 때까지 실행 흐름이 블로킹됩니다.

### 논블로킹

*   **주체**: 실행 흐름 (스레드, 프로세스)
*   **객체**: I/O 작업
*   **의미**: I/O 작업이 백그라운드에서 진행되는 동안 실행 흐름은 블로킹되지 않습니다.

## 결론

*   이벤트 처리기는 반드시 `async`여야 하며, 이는 이벤트 처리기가 블로킹되지 않도록 합니다.
*   REST API 자체는 동기/비동기적이지 않으며, 구현 방식에 따라 비동기적으로 호출할 수 있습니다.
*   `await`는 현재 코루틴의 실행을 일시 중단시키지만, 이벤트 루프는 다른 코루틴을 실행하여 프로그램 전체는 블로킹되지 않습니다.
*   블로킹/논블로킹의 주체는 '실행 흐름'이고 객체는 'I/O 작업'입니다.
